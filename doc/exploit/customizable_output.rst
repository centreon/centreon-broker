.. _exploit_customizable_output:

###################
Customizable output
###################

Centreon Broker makes available a customizable connector. If one does not find
the good connector among all those proposed, surely this customizable output
is the good choice. Its principle is to expose a part of Centreon Broker API
through the Lua interpreter. And the user has just to fill it with his needs.

The exposed Centreon Broker
===========================

Here is the minimal acceptable Lua code to work as customizable output:

.. code-block:: lua

  function init(conf)
  end

  function write(d)
    return 1
  end

When Centreon Broker starts, it initializes all the configured connectors.
For the customizable output, it loads the Lua script, checks its syntax and
verifies that the ``init()`` and ``write()`` functions exists.

Centreon Broker checks also if a function ``filter(category, type)`` exists.

So, let us explain those three functions. ``init`` is called at the connector
initialization. Its argument is a Lua table containing informations given by
the user in the Centreon output broker configuration interface. For example,
if an IP address is given with the name *address* and the value *192.168.1.18*,
then this information will be available with ``conf["address"]``.

The ``write()`` function is called each time an event is received from a
poller by the broker and it has been configured to be sent to this connector.
This function needs one argument that is the event translated as a Lua table.

The ``write()`` must return how many events have been treated.

If this function does not return an integer, Broker will rise an error.

The Broker Lua SDK
==================

To make things simpler for the Lua developer, several objects are proposed and
directly available to the script.

The *broker_log* object
-----------------------

1. ``broker_log:set_parameters(level, filename)`` allows the user to set
   a log level and a file name. The level is an integer from 1 to 3, from the
   more important to the less one. The file name must contain the full path.
   And the file must be accessible to centreon-broker. If this method is not
   called, then logs will be written in the centreon broker logs.
2. ``broker_log:info(level, content)`` writes a log *information* if the
   given level is less or equal to the one configured. The content is the
   text to write in the logs.
3. ``broker_log:warning(level, content)`` works like ``log_info`` but
   writes a *warning*.
4. ``broker_log:error(level, content)`` works like ``log_info`` but writes an
   *error*.

Here is an example:

.. code-block:: lua

  function init(conf)
    -- Here, we allow all logs with level 3 and set the output to
    -- /tmp/test.log.
    broker_log:set_parameters(3, "/tmp/test.log")
  end

  function write(d)
    -- For each entry, we write the key and the value.
    for k,v in pairs(d) do
      broker_log:info(3, k .. " => " .. tostring(v))
    end
  end

Here, when the ``init`` function is executed, the *broker_log* object is
parametrized with a max level 3 and an output file */tmp/test.log*.

Then on each ``write()`` call, events received are logged as
info. We get a result like this:

::

  Fri Jan 26 08:31:49 2018: INFO: service_id => 21
  Fri Jan 26 08:31:49 2018: INFO: type => 0
  Fri Jan 26 08:31:49 2018: INFO: host_id => 13
  Fri Jan 26 08:31:49 2018: INFO: element => 1
  Fri Jan 26 08:31:49 2018: INFO: comment_data =>

**Remark** - To use a method in Lua, the separator between the object and the
method is '*:*' ; *broker_log* is an object since it contains informations
like the max level or the destination file.

The TCP broker socket
---------------------

A basic TCP socket is available in the *Broker* SDK. A simple example is the
following:

.. code-block:: lua

  local socket = broker_tcp_socket.new()
  socket:connect("10.40.1.2", 9002)
  socket:write(message)
  answer = socket:read()
  socket:close()

1. In this example, the first call is *broker_tcp_socket.new()*. It creates a
   new socket by calling the function *new()* stored in the table
   *broker_tcp_socket*.
2. The next step, is a call to the *connect* method that needs two arguments:
   a string given an ip or a host name to connect to and the port to use.
3. The next step is a call to the *write* method that writes a string into
   the socket. The method call is finished when all the message is sent.
4. The *read* method gets a string as result.
5. When the user finishes to use the socket, he can close the socket with the
   *close()* method.

The *broker* table
------------------

Several functions are available in this table. These functions are not
methods, *broker* is just a table containing them. We can find here:

1. ``json_encode(object)`` that converts into json a Lua object. The json is
   returned as string by the function.
2. ``json_decode(json)`` that converts into Lua object a json string. The object
   is directly returned by the method.

.. code-block:: lua

  local obj = {
    a = 1,
    b = 2,
    c = { 'aa', 'bb', 'cc' }
  }
  local json = broker.json_encode(obj)
  print(json)

that returns

::

  { "a": 1, "b": 2, "c": [ 'aa', 'bb', 'cc' ] }

A second example is the following:

.. code-block:: lua

  local json = { "a": 1, "b": 2, "c": [ 'aa', 'bb', 'cc' ] }
  local obj = broker.json_decode(json)

  for i,v in pairs(obj) do
    print(i .. " => " .. tostring(v))
  end

should return something like this:

::

  a => 1
  b => 2
  c => table: 0x12ef67b5

It is also easy to access to each field of the object, for example:
``obj['a']`` gives 1, or ``obj['c'][1]`` gives *aa*, or ``obj.b`` gives 2.

The *broker_cache* object
-------------------------

This object provides several methods to access the cache. Among data, we can
get hostnames, etc...

The available methods are:

1. ``get_hostname(id)`` that gets from the cache the host name corresponding to
   the host id given. This function returns a string with the host name or
   *nil* otherwise.


The init() function
===================

This function must **not** be defined as ``local``, otherwise it will not be
detected by centreon broker.

Imagine we have made a such configuration:

.. image:: config.png
    :width: 600pt
    :align: center
    :alt: alternate text

with two custom entries:

1. a string *elastic-address* with ``172.17.0.1`` as content.
2. a number *elastic-port* with 9200 as content.

Then, the ``init()`` function has access to them like this:

.. code-block:: lua

  function init(conf)
    local my_address = conf['elastic-address']
    local port = conf['elastic-port']
  end

The write() function
====================

This function must **not** be defined as ``local``, otherwise it will not be
seen by broker.

The only argument given to the ``write()`` function is an event. It is given
with the same data as the ones we can see in Centreon Broker.

To classify the event, we have two data that are ``category`` and ``element``.
Those two informations are integers. If we concatenate those two numbers
we obtain a longer integer equal to the event ``type`` also available in the
event.

+-------+----------+------+
| int   |  short   | short|
+-------+----------+------+
|type = | category | elem |
+-------+----------+------+

Sometimes, one can want the hostname corresponding to an event but he only gets
the ``host_id``. It is possible to get it thanks to the
``broker_cache:get_hostname(id)`` method.

For example:

.. code-block:: lua

  function write(d)
    if d.category == 3 and d.element == 1 then
      local hostname = broker_cache:get_hostname(d.host_id)
      if hostname then
        broker_log:info("host name "
            .. hostname .. " corresponds to host id " .. d.host_id)
      else
        -- Unable to get the name, we wait for the next time, wishing
        -- the cache will contain the name. And so return 0
        return 0
      end
    end
    return 1
  end

The filter() function
=====================

The function must **not** be defined as ``local``, otherwise it will not be
detected by Centreon Broker.

It takes two parameters, ``category`` and ``element`` we already seen in
the previous section. The category is an integer from 1 to 7 or 65535. The
``element`` gives details on the event, for example, for the *category NEB*,
*elements* are *Acknowledgement*, *Comment*, etc... given as integers.

For details on types, categories and their id, see
https://documentation.centreon.com/docs/centreon-broker/en/latest/dev/bbdo.html
